- Feature Name: `ko'oi` 
- Start Date: 2019-03-26
- RFC pull request: (leave this empty)

# Summary
[Summary]: #summary

This proposal would add the word `ko'oi`(in selma'o UI) as a generalization of imperatives. `ko'oi` would act as a
generalized imperative marker, and when applied to a sumti would mark the target of the command;
`ko` would expand to `do ko'oi`.


# Background and Motivation
[Background and Motivation]: #background-and-motivation

What was done before? Why are we proposing this? What use cases does it support? What is the expected outcome?

The Lojban systems for dealing with commands are a relatively weak part of the language. Unlike questions,
where substantial consideration was given to the various types of question that might be asked, commands
were kept relatively simple. Currently, one can only give commands to the listener(s), `do`. Alternatively,
one could use `e'o`, which marks a request. However, the CLL uses `e'o` *in addition* to `ko`, suggesting
that `e'o` on its own does not render a bridi a command. Further, the range of uses of `ko` is
substantially broader than `e'o`, covering all cases in which it is the intended effect of the sentence
that some party will comply with it. 

# Guide-level Explanation
[Guide-level Explanation]: #guide-level-explanation

Explain the proposal as if it was already accepted and you were teaching it to a Relojban speaker. That generally means:

- Explaining the proposal in terms of examples.
- Explaining how the proposal impacts the way Relojban users (novices or experts) speak and write the language, how they use the software tools and the other Relojban resources. It should explain the impact as concretely as possible.
- If applicable, provide instruction on how to migrate existing Relojban texts or code to the new approach.


# Reference-level Explanation
[Reference-level Explanation]: #reference-level-explanation

Explain any technical changes (particularly changes in the grammar specifications) in sufficient detail so that:

- It is reasonably clear how the proposal would be implemented.
- It is reasonably clear how it interacts with other features of the language.
- Corner cases are dissected by example.


# Drawbacks
[Drawbacks]: #drawbacks

Why should we *not* do this?


# Alternatives
[Alternatives]: #alternatives

- What other designs have been considered and what is the rationale for not choosing them?
- What is the impact of not doing this?


# Unresolved Questions
[Unresolved Questions]: #unresolved-questions

- What aspects of the proposal need to be ironed out in the RFC discussion before this gets merged?
- What aspects of the proposal are expected to be resolved later, at implementation time?
- What related issues are out of scope for this RFC that could be addressed in the future independently of the solution that comes out of this RFC?
